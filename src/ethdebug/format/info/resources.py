# generated by datamodel-codegen:
#   filename:  resources.schema.yaml
#   timestamp: 2025-04-11T12:46:46+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel, constr


class Type(BaseModel):
    pass


class Identifier(RootModel[constr(pattern=r'^[a-zA-Z_\-]+[a-zA-Z0-9$_\-]*$')]):
    root: constr(pattern=r'^[a-zA-Z_\-]+[a-zA-Z0-9$_\-]*$') = Field(
        ...,
        description='An identifier for use within the context of a root pointer\n',
        examples=['a', 'a0', '-$', '__init__'],
        title='ethdebug/format/pointer/identifier',
    )


class Pointer(BaseModel):
    pass


class Compiler(BaseModel):
    name: str = Field(..., description='Compiler name')
    version: str = Field(
        ...,
        description='Compiler version.\n\nThis value **should** be specified using the most detailed version\nrepresentation available, i.e., including source control hash and\ncompiler build information whenever possible.\n',
    )


class Id(RootModel[Union[float, str]]):
    root: Union[float, str] = Field(
        ...,
        description='An opaque external ID (likely generated by compiler)',
        examples=[5, 'five'],
        title='ethdebug/format/materials/id',
    )


class Source(BaseModel):
    id: Id = Field(
        ...,
        description='Source identifier. This field **must** be unique for all sources\nwithin a single compiler invocation (compilation).\n',
    )
    path: str = Field(
        ...,
        description='Hierarchical file-system-like path to this source. This value may\nbe an absolute path, a path relative to some root directory, a path\nto some resource within a package, etc.\n\nThis value does not need to correspond to any file on disk (either\nphysical or virtual), and might instead refer to a path identifier\nfor a source that was generated by a compiler or other development tool.\n\nThis format makes no specific restrictions on how paths should be\nspecified (e.g., no restriction on path separators, etc.), other than\nthat values for this field should match what users observe elsewhere for\nthe inputs/outputs of this particular compiler invocation.\n\nIf no path information is available for a particular source, e.g. if the\nsource was provided to the compiler via shell standard input, this field\nshould indicate that somehow (e.g., specifying `"path": "stdin"` or\nsimilar).\n\nThis field\'s value **should** be unique across all sources within the\nsame compilation.\n',
    )
    contents: str = Field(
        ...,
        description='The full contents of the source, possibly re-encoded as UTF-8 to\nmatch parent JSON encoding.\n\nIn cases where input source used a different encoding, this object\n**must** also specify an `encoding` property to indicate the\nencoding originally used. Where relevant, debuggers **must** also\nconvert these `contents` back to the specified original encoding so\nas to match code author expectations.\n',
    )
    encoding: Optional[str] = Field(
        None,
        description='Character encoding of original source `contents`. This property\nis **required** if this encoding does not match the JSON transmission\nencoding (UTF-8), since the value of the `contents` property will\nrepresent the text of the source of this JSON encoding.\n\nThis property **must not** appear in objects that do not specify\na `contents` property.\n',
    )
    language: str = Field(
        ...,
        description='The high-level language that the source contents are written in.\n',
    )


class Template(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expect: List[Identifier] = Field(
        ...,
        description='An array of variable identifiers used in the definition of the\npointer template.\n',
        title='Template variables',
    )
    for_: Pointer = Field(..., alias='for')


class Compilation(BaseModel):
    id: Id = Field(
        ...,
        description='Compilation ID\n\nThis value **should** be globally-unique and generated only from the\ncompiler inputs (settings, sources, etc.); the same compiler inputs/\nsettings **should** produce the same identifier.\n',
    )
    compiler: Compiler = Field(
        ...,
        examples=[
            {
                'name': 'lllc',
                'version': '0.4.12-develop.2017.6.27+commit.b83f77e0.Linux.g++',
            }
        ],
        title='Compiler name and version',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None,
        description='Compiler settings in a format native to the compiler.\n\nFor compilers whose settings includes full source representations, this\nfield **should** be specified in such a way that avoids large data\nredundancies (e.g. if compiler settings contain full source\nrepresentations, then this field would significantly duplicate the\ninformation represented by the `sources` field in this object).\n\nIn situations where settings information duplicates information\nrepresented elsewhere in **ethdebug/format**, compilers **may** adopt\nany reasonable strategy, e.g.:\n  - omit duplications partially (leaving the rest of the settings\n    intact)\n  - omit this field entirely\n  - specify this field as a hash of the full settings\n    representation (with the expectation that users of this format will\n    have access to the full representation by some other means)\n',
    )
    sources: List[Source]


class EthdebugFormatInfoResources(BaseModel):
    types: Dict[str, Type] = Field(
        ...,
        description='A collection of types by name identifier.\n',
        title='Types by name',
    )
    pointers: Dict[str, Template] = Field(
        ...,
        description='A collection of pointer templates by name identifier.\n',
        title='Pointer templates by name',
    )
    compilation: Optional[Compilation] = None
