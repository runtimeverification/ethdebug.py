# generated by datamodel-codegen:
#   filename:  info.schema.yaml
#   timestamp: 2025-05-02T06:59:03+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel

from .materials import compilation_schema
from .pointer.collection import conditional_schema
from .pointer.region import base_schema
from .program import context_schema
from .type.complex import alias_schema


class Template(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expect: List[base_schema.Identifier] = Field(
        ...,
        description='An array of variable identifiers used in the definition of the\npointer template.\n',
        title='Template variables',
    )
    for_: conditional_schema.Pointer = Field(..., alias='for')


class Compiler(BaseModel):
    name: str = Field(..., description='Compiler name')
    version: str = Field(
        ...,
        description='Compiler version.\n\nThis value **should** be specified using the most detailed version\nrepresentation available, i.e., including source control hash and\ncompiler build information whenever possible.\n',
    )


class Compilation(BaseModel):
    id: alias_schema.Id = Field(
        ...,
        description='Compilation ID\n\nThis value **should** be globally-unique and generated only from the\ncompiler inputs (settings, sources, etc.); the same compiler inputs/\nsettings **should** produce the same identifier.\n',
    )
    compiler: Compiler = Field(
        ...,
        examples=[
            {
                'name': 'lllc',
                'version': '0.4.12-develop.2017.6.27+commit.b83f77e0.Linux.g++',
            }
        ],
        title='Compiler name and version',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None,
        description='Compiler settings in a format native to the compiler.\n\nFor compilers whose settings includes full source representations, this\nfield **should** be specified in such a way that avoids large data\nredundancies (e.g. if compiler settings contain full source\nrepresentations, then this field would significantly duplicate the\ninformation represented by the `sources` field in this object).\n\nIn situations where settings information duplicates information\nrepresented elsewhere in **ethdebug/format**, compilers **may** adopt\nany reasonable strategy, e.g.:\n  - omit duplications partially (leaving the rest of the settings\n    intact)\n  - omit this field entirely\n  - specify this field as a hash of the full settings\n    representation (with the expectation that users of this format will\n    have access to the full representation by some other means)\n',
    )
    sources: List[compilation_schema.Source]


class Environment(Enum):
    call = 'call'
    create = 'create'


class Resources(BaseModel):
    types: Dict[str, context_schema.Type] = Field(
        ...,
        description='A collection of types by name identifier.\n',
        title='Types by name',
    )
    pointers: Dict[str, Template] = Field(
        ...,
        description='A collection of pointer templates by name identifier.\n',
        title='Pointer templates by name',
    )
    compilation: Optional[Compilation] = None


class Operation(BaseModel):
    mnemonic: str = Field(..., description='The mnemonic operation code (PUSH1, e.g.)')
    arguments: Optional[List[alias_schema.Value]] = Field(
        None,
        description='The immediate arguments to the operation, if relevant.',
        min_length=1,
    )


class Contract(BaseModel):
    name: Optional[str] = None
    definition: alias_schema.SourceRange


class Context(
    RootModel[
        Union[context_schema.Code, context_schema.Variables, context_schema.Remark]
    ]
):
    root: Union[
        context_schema.Code, context_schema.Variables, context_schema.Remark
    ] = Field(
        ...,
        description='A schema for representing the information known at compile-time about the\nhigh-level language concerns at a particular point in code execution.\n',
        examples=[
            {
                'variables': [
                    {
                        'identifier': 'x',
                        'declaration': {
                            'source': {'id': 5},
                            'range': {'offset': 10, 'length': 56},
                        },
                        'type': {'kind': 'string'},
                        'pointer': {'location': 'storage', 'slot': 0},
                    }
                ],
                'code': {'source': {'id': 5}, 'range': {'offset': 68, 'length': 16}},
            }
        ],
        title='ethdebug/format/program/context',
    )


class Instruction(BaseModel):
    offset: alias_schema.Value = Field(
        ...,
        description="The byte offset where the instruction begins within the bytecode.\n\nFor legacy contract bytecode (non-EOF), this value is equivalent to the\ninstruction's program counter. For EOF bytecode, this value **must** be\nthe offset from the start of the container, not the start of a particular\ncode section within that container.\n",
        title='Instruction byte offset',
    )
    operation: Optional[Operation] = Field(None, title='Machine operation information')
    context: Context = Field(
        ...,
        description='The context known to exist following the execution of this instruction.\n',
    )


class Program(BaseModel):
    compilation: Optional[alias_schema.Reference] = Field(
        None,
        description='A reference to the compilation as an `{ "id": ... }` object.\n',
        title='Compilation reference by ID',
    )
    contract: Contract
    environment: Environment = Field(
        ...,
        description='Whether this bytecode is for contract creation or runtime calls.\n',
        title='Bytecode execution environment',
    )
    context: Optional[Context] = Field(
        None,
        description='The context known to exist prior to the execution of the first\ninstruction in the bytecode.\n',
    )
    instructions: List[Instruction] = Field(
        ..., description='The full array of instructions for the bytecode.\n'
    )


class EthdebugFormatInfo(BaseModel):
    programs: List[Program]
    compilation: Compilation
