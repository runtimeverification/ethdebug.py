# generated by datamodel-codegen:
#   filename:  info.schema.yaml
#   timestamp: 2025-04-11T19:10:52+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel, conint, constr


class Type(BaseModel):
    pass


class Identifier(RootModel[constr(pattern=r'^[a-zA-Z_\-]+[a-zA-Z0-9$_\-]*$')]):
    root: constr(pattern=r'^[a-zA-Z_\-]+[a-zA-Z0-9$_\-]*$') = Field(
        ...,
        description='An identifier for use within the context of a root pointer\n',
        examples=['a', 'a0', '-$', '__init__'],
        title='ethdebug/format/pointer/identifier',
    )


class Pointer(BaseModel):
    pass


class Compiler(BaseModel):
    name: str = Field(..., description='Compiler name')
    version: str = Field(
        ...,
        description='Compiler version.\n\nThis value **should** be specified using the most detailed version\nrepresentation available, i.e., including source control hash and\ncompiler build information whenever possible.\n',
    )


class Id(RootModel[Union[float, str]]):
    root: Union[float, str] = Field(
        ...,
        description='An opaque external ID (likely generated by compiler)',
        examples=[5, 'five'],
        title='ethdebug/format/materials/id',
    )


class Source(BaseModel):
    id: Id = Field(
        ...,
        description='Source identifier. This field **must** be unique for all sources\nwithin a single compiler invocation (compilation).\n',
    )
    path: str = Field(
        ...,
        description='Hierarchical file-system-like path to this source. This value may\nbe an absolute path, a path relative to some root directory, a path\nto some resource within a package, etc.\n\nThis value does not need to correspond to any file on disk (either\nphysical or virtual), and might instead refer to a path identifier\nfor a source that was generated by a compiler or other development tool.\n\nThis format makes no specific restrictions on how paths should be\nspecified (e.g., no restriction on path separators, etc.), other than\nthat values for this field should match what users observe elsewhere for\nthe inputs/outputs of this particular compiler invocation.\n\nIf no path information is available for a particular source, e.g. if the\nsource was provided to the compiler via shell standard input, this field\nshould indicate that somehow (e.g., specifying `"path": "stdin"` or\nsimilar).\n\nThis field\'s value **should** be unique across all sources within the\nsame compilation.\n',
    )
    contents: str = Field(
        ...,
        description='The full contents of the source, possibly re-encoded as UTF-8 to\nmatch parent JSON encoding.\n\nIn cases where input source used a different encoding, this object\n**must** also specify an `encoding` property to indicate the\nencoding originally used. Where relevant, debuggers **must** also\nconvert these `contents` back to the specified original encoding so\nas to match code author expectations.\n',
    )
    encoding: Optional[str] = Field(
        None,
        description='Character encoding of original source `contents`. This property\nis **required** if this encoding does not match the JSON transmission\nencoding (UTF-8), since the value of the `contents` property will\nrepresent the text of the source of this JSON encoding.\n\nThis property **must not** appear in objects that do not specify\na `contents` property.\n',
    )
    language: str = Field(
        ...,
        description='The high-level language that the source contents are written in.\n',
    )


class Environment(Enum):
    call = 'call'
    create = 'create'


class Type1(Enum):
    compilation = 'compilation'
    source = 'source'


class Reference(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Id
    type: Optional[Type1] = None


class Unsigned(RootModel[conint(ge=0)]):
    root: conint(ge=0) = Field(
        ...,
        description='A non-negative integer encoded as a JSON number.\n',
        examples=[0, 100],
        title='ethdebug/format/data/unsigned',
    )


class Hex(RootModel[constr(pattern=r'^0x[0-9a-fA-F]{1,}$')]):
    root: constr(pattern=r'^0x[0-9a-fA-F]{1,}$') = Field(
        ...,
        description='A `0x`-prefixed hexadecimal string. This value **must** contain at least one\nhexadecimal character (`0x` by itself is not allowed).\n',
        examples=['0x0000', '0x1'],
        title='ethdebug/format/data/hex',
    )


class ReferenceModel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Union[str, float]


class Remark(BaseModel):
    remark: str


class Template(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expect: List[Identifier] = Field(
        ...,
        description='An array of variable identifiers used in the definition of the\npointer template.\n',
        title='Template variables',
    )
    for_: Pointer = Field(..., alias='for')


class Compilation(BaseModel):
    id: Id = Field(
        ...,
        description='Compilation ID\n\nThis value **should** be globally-unique and generated only from the\ncompiler inputs (settings, sources, etc.); the same compiler inputs/\nsettings **should** produce the same identifier.\n',
    )
    compiler: Compiler = Field(
        ...,
        examples=[
            {
                'name': 'lllc',
                'version': '0.4.12-develop.2017.6.27+commit.b83f77e0.Linux.g++',
            }
        ],
        title='Compiler name and version',
    )
    settings: Optional[Dict[str, Any]] = Field(
        None,
        description='Compiler settings in a format native to the compiler.\n\nFor compilers whose settings includes full source representations, this\nfield **should** be specified in such a way that avoids large data\nredundancies (e.g. if compiler settings contain full source\nrepresentations, then this field would significantly duplicate the\ninformation represented by the `sources` field in this object).\n\nIn situations where settings information duplicates information\nrepresented elsewhere in **ethdebug/format**, compilers **may** adopt\nany reasonable strategy, e.g.:\n  - omit duplications partially (leaving the rest of the settings\n    intact)\n  - omit this field entirely\n  - specify this field as a hash of the full settings\n    representation (with the expectation that users of this format will\n    have access to the full representation by some other means)\n',
    )
    sources: List[Source]


class Value(RootModel[Union[Unsigned, Hex]]):
    root: Union[Unsigned, Hex] = Field(
        ...,
        description='A non-negative integer value, expressed either as a native JSON number or as\na `0x`-prefixed hexadecimal string.\n',
        examples=['0x0000', 2],
        title='ethdebug/format/data/value',
    )


class Operation(BaseModel):
    mnemonic: str = Field(..., description='The mnemonic operation code (PUSH1, e.g.)')
    arguments: Optional[List[Value]] = Field(
        None,
        description='The immediate arguments to the operation, if relevant.',
        min_length=1,
    )


class Resources(BaseModel):
    types: Dict[str, Type] = Field(
        ...,
        description='A collection of types by name identifier.\n',
        title='Types by name',
    )
    pointers: Dict[str, Template] = Field(
        ...,
        description='A collection of pointer templates by name identifier.\n',
        title='Pointer templates by name',
    )
    compilation: Optional[Compilation] = None


class Range(BaseModel):
    offset: Value = Field(..., description='Byte offset at beginning of range.\n')
    length: Value = Field(..., description='Number of bytes contained in range')


class SourceRange(BaseModel):
    compilation: Optional[Reference] = Field(None, title='Compilation reference by ID')
    source: Reference = Field(..., title='Source reference by ID')
    range: Optional[Range] = Field(
        None,
        description='Ranges that span the entire source contents **may** omit this field\nas a shorthand. This field is otherwise **required**.\n',
        title='Bytes range within source contents',
    )


class Code(BaseModel):
    code: SourceRange


class Variable(BaseModel):
    identifier: Optional[constr(min_length=1)] = None
    declaration: Optional[SourceRange] = Field(
        None,
        description='Source range corresponding to where the variable was declared.\n',
    )
    type: Optional[Union[Type, ReferenceModel]] = Field(
        None,
        description='The variable\'s static type, if it exists. This **must** be specified\neither as a full **ethdebug/format/type** representation, or an\n`{ "id": "..." }` type reference object.\n',
    )
    pointer: Optional[Pointer] = Field(
        None, description='Allocation information for the variable, if it exists.\n'
    )


class Contract(BaseModel):
    name: Optional[str] = None
    definition: SourceRange


class Variables(BaseModel):
    variables: List[Variable] = Field(..., min_length=1)


class Context(RootModel[Union[Code, Variables, Remark]]):
    root: Union[Code, Variables, Remark] = Field(
        ...,
        description='A schema for representing the information known at compile-time about the\nhigh-level language concerns at a particular point in code execution.\n',
        examples=[
            {
                'variables': [
                    {
                        'identifier': 'x',
                        'declaration': {
                            'source': {'id': 5},
                            'range': {'offset': 10, 'length': 56},
                        },
                        'type': {'kind': 'string'},
                        'pointer': {'location': 'storage', 'slot': 0},
                    }
                ],
                'code': {'source': {'id': 5}, 'range': {'offset': 68, 'length': 16}},
            }
        ],
        title='ethdebug/format/program/context',
    )


class Instruction(BaseModel):
    offset: Value = Field(
        ...,
        description="The byte offset where the instruction begins within the bytecode.\n\nFor legacy contract bytecode (non-EOF), this value is equivalent to the\ninstruction's program counter. For EOF bytecode, this value **must** be\nthe offset from the start of the container, not the start of a particular\ncode section within that container.\n",
        title='Instruction byte offset',
    )
    operation: Optional[Operation] = Field(None, title='Machine operation information')
    context: Context = Field(
        ...,
        description='The context known to exist following the execution of this instruction.\n',
    )


class Program(BaseModel):
    compilation: Optional[Reference] = Field(
        None,
        description='A reference to the compilation as an `{ "id": ... }` object.\n',
        title='Compilation reference by ID',
    )
    contract: Contract
    environment: Environment = Field(
        ...,
        description='Whether this bytecode is for contract creation or runtime calls.\n',
        title='Bytecode execution environment',
    )
    context: Optional[Context] = Field(
        None,
        description='The context known to exist prior to the execution of the first\ninstruction in the bytecode.\n',
    )
    instructions: List[Instruction] = Field(
        ..., description='The full array of instructions for the bytecode.\n'
    )


class EthdebugFormatInfo(BaseModel):
    programs: List[Program]
    compilation: Compilation
