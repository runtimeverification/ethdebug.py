# generated by datamodel-codegen:
#   filename:  type/complex/function.schema.yaml
#   timestamp: 2025-05-02T06:59:03+00:00

from __future__ import annotations

from typing import List, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel

from . import alias_schema
from .alias_schema import Wrapper


class Element(Wrapper):
    name: Optional[str] = Field(
        None,
        description='For tuple types where positional element types are identified by name, this field **should** include this information.\nThis schema makes no restriction on whether all-or-no elements have names, and so this field may be sparse across elements of the same tuple.',
    )


class Tuple(BaseModel):
    class_: Literal['complex'] = Field('complex', alias='class')
    kind: Literal['tuple']
    contains: List[Element]


class Parameters(Wrapper):
    type: Optional[Tuple] = None


class Contains1(BaseModel):
    parameters: Parameters
    returns: Optional[Union[alias_schema.Wrapper, Parameters]] = Field(
        None,
        description='To accommodate languages differing in whether functions return single\nvalues or lists of values, this field may be either a generic type\nwrapper or explicitly defined as a type wrapper around a tuple type.\n\nDebuggers that implement this schema **should** be aware that\nlanguages whose functions return sole values might return tuple\ntypes. Resolving this ambiguity remains outside the scope of the\nschema (but compilers **must** be consistent when representing\nfunction types in this schema).\n',
        title='Return type (or tuple of types)',
    )


class EthdebugFormatTypeComplexFunction2(BaseModel):
    class_: Literal['complex'] = Field('complex', alias='class')
    kind: Literal['function'] = 'function'
    contains: Optional[Contains1] = Field(
        None,
        description="Types this function type composes. Function types inherently compose\ntwo groupings of types (an ordered list of parameter types and typically\neither a return value or return parameters). Function types' `contains`\nfield is organized as a mapping of `parameters` types (a type wrapper for\na tuple type) and an optional `returns` type (either a generic type\nwrapper or a type wrapper for a tuple type).\n\nThis definition applies for both cases (internal and external function\ntypes). Each of those specific types may expand this `contains` field\nschema with other semantic details (such as an external function type\nindicating the contract type from which it is exposed).\n",
        title='Parameter and return types',
    )
    definition: Optional[alias_schema.Definition] = None
    internal: Literal[True]
    external: Literal[False] = False


class Contract1(BaseModel):
    class_: Literal['elementary'] = Field('elementary', alias='class')
    kind: Literal['contract']
    payable: Optional[bool] = Field(
        None,
        description='If this field is omitted, this type represents an address whose payability is not known.',
    )
    definition: Optional[alias_schema.Definition] = None
    library: Literal[False] = False
    interface: Literal[False] = False


class Contract2(BaseModel):
    class_: Literal['elementary'] = Field('elementary', alias='class')
    kind: Literal['contract']
    payable: Optional[bool] = Field(
        None,
        description='If this field is omitted, this type represents an address whose payability is not known.',
    )
    definition: Optional[alias_schema.Definition] = None
    library: Literal[True] = Field(
        ..., description='Indicates that this is a type representing a library'
    )


class Contract3(BaseModel):
    class_: Literal['elementary'] = Field('elementary', alias='class')
    kind: Literal['contract']
    payable: Optional[bool] = Field(
        None,
        description='If this field is omitted, this type represents an address whose payability is not known.',
    )
    definition: Optional[alias_schema.Definition] = None
    interface: Literal[True] = Field(
        ..., description='Indicates that this is a type representing an interface'
    )


class Contract(RootModel[Union[Contract1, Contract2, Contract3]]):
    root: Union[Contract1, Contract2, Contract3] = Field(
        ...,
        description='Schema describing the representation of a contract type',
        examples=[
            {'kind': 'contract'},
            {'kind': 'contract', 'library': False, 'interface': False, 'payable': True},
        ],
        title='ethdebug/format/type/elementary/contract',
    )


class ContractModel(Wrapper):
    type: Optional[Contract] = None


class Contains(BaseModel):
    parameters: Parameters
    returns: Optional[Union[alias_schema.Wrapper, Parameters]] = Field(
        None,
        description='To accommodate languages differing in whether functions return single\nvalues or lists of values, this field may be either a generic type\nwrapper or explicitly defined as a type wrapper around a tuple type.\n\nDebuggers that implement this schema **should** be aware that\nlanguages whose functions return sole values might return tuple\ntypes. Resolving this ambiguity remains outside the scope of the\nschema (but compilers **must** be consistent when representing\nfunction types in this schema).\n',
        title='Return type (or tuple of types)',
    )
    contract: Optional[ContractModel] = Field(
        None,
        description='A wrapper around the contract type that composes this external function type.',
        title='Contract type providing external function',
    )


class EthdebugFormatTypeComplexFunction1(BaseModel):
    class_: Literal['complex'] = Field('complex', alias='class')
    kind: Literal['function'] = 'function'
    contains: Optional[Contains] = Field(
        None,
        description="Types this function type composes. Function types inherently compose\ntwo groupings of types (an ordered list of parameter types and typically\neither a return value or return parameters). Function types' `contains`\nfield is organized as a mapping of `parameters` types (a type wrapper for\na tuple type) and an optional `returns` type (either a generic type\nwrapper or a type wrapper for a tuple type).\n\nThis definition applies for both cases (internal and external function\ntypes). Each of those specific types may expand this `contains` field\nschema with other semantic details (such as an external function type\nindicating the contract type from which it is exposed).\n",
        title='Additional contents',
    )
    definition: Optional[alias_schema.Definition] = None
    internal: Literal[False] = False
    external: Literal[True]


class EthdebugFormatTypeComplexFunction(
    RootModel[
        Union[EthdebugFormatTypeComplexFunction1, EthdebugFormatTypeComplexFunction2]
    ]
):
    root: Union[
        EthdebugFormatTypeComplexFunction1, EthdebugFormatTypeComplexFunction2
    ] = Field(
        ...,
        description='Schema for representing a function type.\n\nType representations must indicate whether they represent a function that is\ncalled internally (within the semantics of the language) or a function that\nis called externally (via EVM contract call semantics and the Solidity ABI).\nInternal function types require the `"internal": true` field; external\nfunction types require `"external": true`.\n\nNote that external function types may include a representation of the\ncontract type that defines or provides this function as an external\ninterface.\n',
        examples=[
            {
                'kind': 'function',
                'internal': True,
                'definition': {'name': 'increment'},
                'contains': {
                    'parameters': {
                        'type': {
                            'kind': 'tuple',
                            'contains': [
                                {'name': 'value', 'type': {'kind': 'uint', 'bits': 256}}
                            ],
                        }
                    },
                    'returns': {'type': {'kind': 'uint', 'bits': 256}},
                },
            },
            {
                'kind': 'function',
                'external': True,
                'definition': {'name': 'withdraw'},
                'contains': {
                    'contract': {
                        'type': {
                            'kind': 'contract',
                            'payable': True,
                            'interface': True,
                            'definition': {'name': 'Bank'},
                        }
                    },
                    'parameters': {
                        'type': {
                            'kind': 'tuple',
                            'contains': [
                                {
                                    'name': 'beneficiary',
                                    'type': {'kind': 'address', 'payable': True},
                                },
                                {
                                    'name': 'amount',
                                    'type': {
                                        'kind': 'ufixed',
                                        'bits': 128,
                                        'places': 18,
                                    },
                                },
                            ],
                        }
                    },
                    'returns': {'type': {'kind': 'tuple', 'contains': []}},
                },
            },
        ],
        title='ethdebug/format/type/complex/function',
    )
