# generated by datamodel-codegen:
#   filename:  type/base.schema.yaml
#   timestamp: 2025-05-02T06:59:03+00:00

from __future__ import annotations

from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class ElementaryType(BaseModel):
    class_: Literal['elementary'] = Field('elementary', alias='class')
    kind: str
    contains: Optional[Any] = None


class Reference(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Union[str, float]


class EthdebugFormatTypeBase(RootModel[Union[ElementaryType, ComplexType]]):
    root: Union[ElementaryType, ComplexType] = Field(
        ...,
        description='Defines the minimally necessary schema for a data type. Types belong to a particular `class` (`"elementary"` or `"complex"`), and are further identified by a particular `kind`.',
        title='ethdebug/format/type/base',
    )


class ComplexType(BaseModel):
    class_: Literal['complex'] = Field(
        'complex', alias='class', description='Indicates that this is a complex type'
    )
    kind: str = Field(
        ..., description='The specific kind of complex type, e.g., array or struct'
    )
    contains: Union[TypeWrapper, TypeWrapperArray, TypeWrapperObject] = Field(
        ...,
        description='Either a type wrapper, an array of type wrappers, or an object mapping to type wrappers.',
        title='Complex type `contains` field',
    )


class TypeWrapper(BaseModel):
    type: Union[EthdebugFormatTypeBase, Reference]


class TypeWrapperArray(RootModel[List[TypeWrapper]]):
    root: List[TypeWrapper] = Field(
        ...,
        description='A list of wrapped types, where the wrapper may add fields',
        title='{ "type": ... }[]',
    )


class TypeWrapperObject(RootModel[Optional[Dict[str, TypeWrapper]]]):
    root: Optional[Dict[str, TypeWrapper]] = None


EthdebugFormatTypeBase.model_rebuild()
ComplexType.model_rebuild()
