# generated by datamodel-codegen:
#   filename:  type/base.schema.yaml

from __future__ import annotations

from typing import Annotated, Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel

from .reference_schema import TypeReference


class Elementarytype(BaseModel):
    class_: Annotated[Literal['elementary'], Field(alias='class')] = 'elementary'
    kind: str
    contains: Optional[Any] = None


class TypeBase(RootModel[Union[Elementarytype, Complextype]]):
    root: Annotated[
        Union[Elementarytype, Complextype],
        Field(
            description='Defines the minimally necessary schema for a data type. Types belong to a particular `class` (`"elementary"` or `"complex"`), and are further identified by a particular `kind`.',
            title='ethdebug/format/type/base',
        ),
    ]


class Complextype(BaseModel):
    class_: Annotated[
        Literal['complex'],
        Field(alias='class', description='Indicates that this is a complex type'),
    ] = 'complex'
    kind: Annotated[
        str,
        Field(description='The specific kind of complex type, e.g., array or struct'),
    ]
    contains: Annotated[
        Union[Typewrapper, Typewrapperarray, Typewrapperobject],
        Field(
            description='Either a type wrapper, an array of type wrappers, or an object mapping to type wrappers.',
            title='Complex type `contains` field',
        ),
    ]


class Typewrapper(BaseModel):
    type: Union[TypeBase, TypeReference]


class Typewrapperarray(RootModel[List[Typewrapper]]):
    root: Annotated[
        List[Typewrapper],
        Field(
            description='A list of wrapped types, where the wrapper may add fields',
            title='{ "type": ... }[]',
        ),
    ]


class Typewrapperobject(RootModel[Optional[Dict[str, Typewrapper]]]):
    root: Optional[Dict[str, Typewrapper]] = None


TypeBase.model_rebuild()
Complextype.model_rebuild()
