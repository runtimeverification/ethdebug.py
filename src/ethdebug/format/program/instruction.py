# generated by datamodel-codegen:
#   filename:  instruction.schema.yaml
#   timestamp: 2025-04-11T18:30:33+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel, conint, constr


class Unsigned(RootModel[conint(ge=0)]):
    root: conint(ge=0) = Field(
        ...,
        description='A non-negative integer encoded as a JSON number.\n',
        examples=[0, 100],
        title='ethdebug/format/data/unsigned',
    )


class Hex(RootModel[constr(pattern=r'^0x[0-9a-fA-F]{1,}$')]):
    root: constr(pattern=r'^0x[0-9a-fA-F]{1,}$') = Field(
        ...,
        description='A `0x`-prefixed hexadecimal string. This value **must** contain at least one\nhexadecimal character (`0x` by itself is not allowed).\n',
        examples=['0x0000', '0x1'],
        title='ethdebug/format/data/hex',
    )


class Type(Enum):
    compilation = 'compilation'
    source = 'source'


class Id(RootModel[Union[float, str]]):
    root: Union[float, str] = Field(
        ...,
        description='An opaque external ID (likely generated by compiler)',
        examples=[5, 'five'],
        title='ethdebug/format/materials/id',
    )


class TypeModel(BaseModel):
    pass


class Reference(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Union[str, float]


class Pointer(BaseModel):
    pass


class Remark(BaseModel):
    remark: str


class Value(RootModel[Union[Unsigned, Hex]]):
    root: Union[Unsigned, Hex] = Field(
        ...,
        description='A non-negative integer value, expressed either as a native JSON number or as\na `0x`-prefixed hexadecimal string.\n',
        examples=['0x0000', 2],
        title='ethdebug/format/data/value',
    )


class Range(BaseModel):
    offset: Value = Field(..., description='Byte offset at beginning of range.\n')
    length: Value = Field(..., description='Number of bytes contained in range')


class ReferenceModel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Id
    type: Optional[Type] = None


class Operation(BaseModel):
    mnemonic: str = Field(..., description='The mnemonic operation code (PUSH1, e.g.)')
    arguments: Optional[List[Value]] = Field(
        None,
        description='The immediate arguments to the operation, if relevant.',
        min_length=1,
    )


class SourceRange(BaseModel):
    compilation: Optional[ReferenceModel] = Field(
        None, title='Compilation reference by ID'
    )
    source: ReferenceModel = Field(..., title='Source reference by ID')
    range: Optional[Range] = Field(
        None,
        description='Ranges that span the entire source contents **may** omit this field\nas a shorthand. This field is otherwise **required**.\n',
        title='Bytes range within source contents',
    )


class Variable(BaseModel):
    identifier: Optional[constr(min_length=1)] = None
    declaration: Optional[SourceRange] = Field(
        None,
        description='Source range corresponding to where the variable was declared.\n',
    )
    type: Optional[Union[TypeModel, Reference]] = Field(
        None,
        description='The variable\'s static type, if it exists. This **must** be specified\neither as a full **ethdebug/format/type** representation, or an\n`{ "id": "..." }` type reference object.\n',
    )
    pointer: Optional[Pointer] = Field(
        None, description='Allocation information for the variable, if it exists.\n'
    )


class Code(BaseModel):
    code: SourceRange


class Variables(BaseModel):
    variables: List[Variable] = Field(..., min_length=1)


class Context(RootModel[Union[Code, Variables, Remark]]):
    root: Union[Code, Variables, Remark] = Field(
        ...,
        description='A schema for representing the information known at compile-time about the\nhigh-level language concerns at a particular point in code execution.\n',
        examples=[
            {
                'variables': [
                    {
                        'identifier': 'x',
                        'declaration': {
                            'source': {'id': 5},
                            'range': {'offset': 10, 'length': 56},
                        },
                        'type': {'kind': 'string'},
                        'pointer': {'location': 'storage', 'slot': 0},
                    }
                ],
                'code': {'source': {'id': 5}, 'range': {'offset': 68, 'length': 16}},
            }
        ],
        title='ethdebug/format/program/context',
    )


class EthdebugFormatProgramInstruction(BaseModel):
    offset: Value = Field(
        ...,
        description="The byte offset where the instruction begins within the bytecode.\n\nFor legacy contract bytecode (non-EOF), this value is equivalent to the\ninstruction's program counter. For EOF bytecode, this value **must** be\nthe offset from the start of the container, not the start of a particular\ncode section within that container.\n",
        title='Instruction byte offset',
    )
    operation: Optional[Operation] = Field(None, title='Machine operation information')
    context: Context = Field(
        ...,
        description='The context known to exist following the execution of this instruction.\n',
    )
