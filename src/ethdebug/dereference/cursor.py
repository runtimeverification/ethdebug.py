from __future__ import annotations

from dataclasses import dataclass
from typing import AsyncIterable, Callable

from ethdebug.data import Data
from ethdebug.format.pointer.expression_schema import PointerExpression
from ..machine import MachineState
from ..read import read
from ..cursor import Regions as RegionsABC, Region as RegionABC, Cursor as CursorABC, View as ViewABC

class Cursor(CursorABC):
    """
    A cursor that allows viewing and reading from a machine state.
    """
    _simple_cursor: Callable[[MachineState], AsyncIterable[Region]]

    def __init__(self, simple_cursor: Callable[[MachineState], AsyncIterable[Region]]):
        self._simple_cursor = simple_cursor

    async def view(self, state: MachineState) -> View:
        """
        View the cursor with a given MachineState
        """
        regions_list = []
        async for region in self._simple_cursor(state):
            regions_list.append(region)

        regions = Regions(tuple(regions_list))
        return View(state, regions)
    
class View(ViewABC):
    """
    The result of viewing a Cursor with a given MachineState
    """
    _state: MachineState
    _regions: Regions

    def __init__(self, state: MachineState, regions: Regions):
        self._state = state
        self._regions = regions

    def regions(self) -> Regions:
        """
        Get the regions from the view
        """
        return self._regions

    async def read(self, region: Region) -> Data:
        """
        Read bytes from the machine state corresponding to the bytes range
        for a particular concrete Region
        """
        return await read(region, self._state)

@dataclass
class Region(RegionABC):
    """
    A partially evaluated region. Each component can either be a
    pointer or a data value.
    """
    location: str
    name: str | None
    slot: PointerExpression | Data | None
    offset: PointerExpression | Data | None
    length: PointerExpression | Data | None

@dataclass
class Regions(RegionsABC):
    """
    An immutable collection of concrete regions.

    This collection serves as a plain list of regions, for simple iteration
    and whatever filtering.

    It also provides a couple interfaces of its own for accessing regions by
    name.
    """
    _regions: tuple[RegionABC, ...]
    _this_region: RegionABC | None = None

    def all(self) -> tuple[RegionABC, ...]:
        """
        Get all regions in the collection
        """
        return self._regions
    
    def set_this(self, region: RegionABC) -> RegionsABC:
        """
        Replace the current `$this` region with a new one.
        """
        return Regions(self._regions, region)

    def named(self, name: str) -> tuple[RegionABC, ...]:
        """
        Obtain an ordered list of all regions with a particular name.

        This is useful, e.g., when looking to concatenate a series of
        sequential regions that were generated by index from a list
        collection
        """
        if name == "$this":
            return (self._this_region,) if self._this_region else tuple()
        return tuple(region for region in self._regions if region.name == name)

    def lookup(self, name: str) -> RegionABC | None:
        """
        Obtain an ordered list of all regions with a particular name.
        
        This is useful, e.g., when looking to concatenate a series of
        sequential regions that were generated by index from a list
        collection
        """
        if name == "$this":
            return self._this_region
        for region in reversed(self._regions):
            if region.name == name:
                return region
        return None
