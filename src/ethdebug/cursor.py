from __future__ import annotations
from typing import Protocol
from ethdebug.data import Data

class View:
    """
    The result of viewing a Cursor with a given Machine.State
    """
    def __init__(self, regions: Regions):
        self.regions = regions

    async def read(self, region: Region) -> Data:
        """
        Read bytes from the machine state corresponding to the bytes range
        for a particular concrete Region
        """
        # Implementation goes here
        pass

class Region(Protocol):
    location: str
    name: str | None
    slot: Data | None
    offset: Data | None
    length: Data | None

class Regions:
    """
    A collection of concrete regions.

    This collection serves as a plain list of regions, for simple iteration
    and whatever filtering.

    It also provides a couple interfaces of its own for accessing regions by
    name.
    """

    _regions: tuple[Region, ...]

    def __init__(self, regions: tuple[Region, ...]):
        self._regions = regions

    def named(self, name: str) -> tuple[Region, ...]:
        """
        Obtain an ordered list of all regions with a particular name.

        This is useful, e.g., when looking to concatenate a series of
        sequential regions that were generated by index from a list
        collection
        """
        return [region for region in self._regions if region.name == name]

    def lookup(self, name: str) -> Region | None:
        """
        Obtain an ordered list of all regions with a particular name.
        
        This is useful, e.g., when looking to concatenate a series of
        sequential regions that were generated by index from a list
        collection
        """
        for region in reversed(self._regions):
            if getattr(region, 'name', None) == name:
                return region
        return None
